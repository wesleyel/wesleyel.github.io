[{"content":" 完整文档可以在官方网站找到。\n快速开始一个 buildroot 项目 1 2 3 4 5 6 7 8 buildroot_repo=https://github.com/buildroot/buildroot.git buildroot_version=2022.11 buildroot_src=buildroot-$buildroot_version buildroot_defcfg=raspberrypi4_defconfig git clone --branch $buildroot_version --depth 1 $buildroot_repo make -C $buildroot_src defconfig BR2_DEFCONFIG=$buildroot_defcfg make -C $buildroot_src linux-reconfigure all 基本命令 Make 提示\n使用 make help 获取所有可用目标的列表。\n命令 描述 make 构建 rootfs make xyz_defconfig 选择配置文件 make menuconfig 打开配置菜单 make savedefconfig 将当前配置保存到 defconfig 文件中 make source 下载包的源代码 make clean 清理所有构建产品（包括构建目录、主机、暂存和目标树、镜像和工具链） make distclean 清理所有内容，包括配置 包管理 特定包的 make 目标\n命令 描述 make \u0026lt;pkg\u0026gt; 构建一个包 make \u0026lt;pkg\u0026gt;-reinstall 重新安装一个包 make \u0026lt;pkg\u0026gt;-rebuild 重新构建一个包（这意味着重新安装） make \u0026lt;pkg\u0026gt;-reconfigure 重新配置一个包（这意味着重新构建） make \u0026lt;pkg\u0026gt;-dirclean 清理包目录 调试 命令 描述 make graph-depends 生成依赖关系图 make \u0026lt;pkg\u0026gt;-graph-depends 生成包的依赖关系图 目录结构 目录 描述 configs 单板的配置和 defconfig 文件的位置 package 包定义的位置 dl 下载的源代码压缩包 output/build 所有组件构建的目录 output/images 构建的内核、引导加载程序和根文件系统镜像的位置 output/staging 交叉编译工具链和用户空间包的头文件和库的位置（这是 host//sysroot 的软链） output/host 包括交叉编译工具链在内的主机工具的位置 output/target 几乎是最终的目标根文件系统 .mk 文件 Cmake cmake 包教程\n一个 cmake 包的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ################################################################################ # # libfoo # ################################################################################ LIBFOO_VERSION = 1.0 LIBFOO_SOURCE = libfoo-$(LIBFOO_VERSION).tar.gz LIBFOO_SITE = http://www.foosoftware.org/download LIBFOO_INSTALL_STAGING = YES LIBFOO_INSTALL_TARGET = NO LIBFOO_CONF_OPTS = -DBUILD_DEMOS=ON LIBFOO_DEPENDENCIES = libglib2 host-pkgconf $(eval $(cmake-package)) 外部包和 sysvinit 一个带有 sysvinit 的外部包示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ################################################################################ # # gsmmux 项目 # ################################################################################ GSMMUX_SITE = $(TOPDIR)/../external/path/gsmmux GSMMUX_SITE_METHOD = local GSMMUX_INSTALL_STAGING = YES GSMMUX_VERSION = 1.0 define GSMMUX_INSTALL_INIT_SYSV $(INSTALL) -D -m 755 $(@D)/S50start_cmuxd \\ $(TARGET_DIR)/etc/init.d/S50start_cmuxd endef $(eval $(cmake-package)) 如何设置 ccache（编译缓存）？ 在 Buildroot 中使用 ccache\nccache 支持已集成在 Buildroot 中。只需在 Build options 中启用 Enable compiler cache。这将自动构建 ccache 并将其用于每个主机和目标编译。\ncache 位于 BR2_CCACHE_DIR 配置选项定义的目录中，默认值为 $HOME/.buildroot-ccache。此默认位置在 Buildroot 输出目录之外，因此可以由单独的 Buildroot 构建共享。如果要删除缓存，只需删除此目录。\n如何重新生成 target/rootfs How to clean only target in buildroot\n由于rm -rf output/target \u0026amp;\u0026amp; make并不会触发 install 操作，所以需要用以下 hack 来实现：\n1 2 3 4 5 6 rm -rf output/target # 删除所有的 .stamp_target_installed 文件 find ../ -name \u0026#34;.stamp_target_installed\u0026#34; -delete rm -f output/build/host-gcc-final-*/.stamp_host_installed ","date":"2024-09-04T00:00:00Z","permalink":"https://wesleyel.github.io/p/buildroot-cheatsheet/","title":"Buildroot 速查"},{"content":" 完整文档可以在Yocto 文档网站找到。 参考自yoctoproject-cheatsheet。\nCli 命令 需要先通过source setup-environment设置Bitbake环境\n命令 描述 bitbake 编译指定的 image bitbake -c 执行指定的 task。 可选的 task 有: fetch, unpack, patch, configure, compile, install, package, clean, cleansstate, rebuild, reconfigure, reinstall等。 bitbake -c cleanall 清理指定的 recipe. 包括工作目录和 sstate cache bitbake -c devshell 进入指定 recipe 的 shell 环境 bitbake -c listtasks 列出指定 recipe 的所有 task bitbake -c showappends 显示指定 recipe 的所有 append 文件 bitbake -e 显示指定 recipe 的所有变量 bitbake -s 列出所有可用的 recipe bitbake -S 显示指定 recipe 的依赖关系 bitbake \u0026ndash;graphviz \u0026ndash;ui=depexp 生成的包依赖关系图 bitbake-layers show-layers 显示所有的 layer bitbake-layers show-appends 显示所有的 append 文件 bitbake-layers show-recipes 显示所有的 recipe bitbake-layers show-recipes \u0026ldquo;gdb*\u0026rdquo; 搜索 recipe bitbake-layers show-depends 显示所有的依赖关系 变量语法和操作 参考自Bitbake User Manual\n可以随时使用 bitbake -e 查看编译时的变量。\n语法 描述 VARIABLE = \u0026quot;value\u0026quot; 设置变量 VARIABLE = \u0026quot; value \u0026quot; 如果变量值中有空格，那么空格会被保留 VARIABLE = \u0026quot;\u0026quot; 设置变量为空 VARIABLE = \u0026quot; \u0026quot; 设置变量为一个空格 VARIABLE = '\u0026quot;' 通过单引号设置含有双引号的变量 VARIABLE = \u0026quot;${OTHER_VARIABLE}\u0026quot; 引用其他变量, 变量在真正使用时才会被展开 VARIABLE := \u0026quot;${OTHER_VARIABLE}\u0026quot; 设置变量，立即展开 VARIABLE ?= \u0026quot;value\u0026quot; 设置默认值，如果变量已经设置，那么不会覆盖 VARIABLE ??= \u0026quot;value\u0026quot; 设置弱默认值，见弱默认值 VARIABLE += \u0026quot;value\u0026quot; 追加变量值（带空格） VARIABLE =+ \u0026quot;value\u0026quot; 在变量值前面追加（带空格） VARIABLE .= \u0026quot;value\u0026quot; 追加变量值（无空格） VARIABLE =. \u0026quot;value\u0026quot; 在变量值后面追加（无空格） TODO\nlocal.conf 配置 这些配置可以加入到 local.conf 或者bblayers.conf文件中，也根据需求加入其他 Machine 配置中。\n配置 作用 RM_WORK_EXCLUDE += \u0026quot;recipe_name\u0026quot; 编译后不删除指定的 recipe 的工作目录，用于调试 INHERIT += \u0026quot;rm_work\u0026quot; 编译后删除工作目录 FAQ NOTE: Reconnecting to bitbake server 删除 bitbake.lock\n1 rm -rf \u0026lt;build-dir\u0026gt;/bitbake.lock ERROR: nothing provides A needed by B 情况一： recipe A 不存在，没有被添加到 packagegroup 或者 dependcy 中 情况二： recipe A 编出来是空包，没有生成任何文件。需要在 A 的 recipe 中添加 ALLOW_EMPTY_${PN} = \u0026quot;1\u0026quot; 来解决 经常在编译动态库时会遇到这个问题，因为动态库的 recipe 生成的是一个空包。\nYocto / OE : recipe with CMake install a shared library .so - Stack Overflow do_rootfs missing package (ipk) or not found in base feeds (rpm) (yoctoproject.org)\n只有 *.so.*（包含版本号的动态库）会被打包进 FILES_${PN}，而软链接 *.so 会被打包进 -devpackage\n如何使用 devtool 新增patch bitbake - What is best practice to do small changes in source code in Yocto - Stack Overflow\n1 2 3 4 5 6 7 8 9 devtool modify -x \u0026lt;recipe\u0026gt; \u0026lt;path-to-unpack\u0026gt; devtool build \u0026lt;recipe\u0026gt; # 修改位于\u0026lt;path-to-unpack\u0026gt;的源码 git add git commit devtool update-recipe \u0026lt;recipe\u0026gt; devtool reset \u0026lt;recipe\u0026gt; ","date":"2024-09-04T00:00:00Z","permalink":"https://wesleyel.github.io/p/yocto-cheetsheet/","title":"Yocto \u0026 Bitbake 速查"},{"content":"内存布局 一般而言，C程序通常由一下几个部分组成。\n正文段\n正文段是用于存储代码的，也称之为代码段。如果函数是可重入的，那么代码段是可以共享的。正文段通常都是只读的，以防止被更改。 初始化数据段\n初始化数据段包含了程序中需要明确初始化的变量。 未初始化数据段\n未初始化数据段也被称为bss段。这里的存放的数据是交由内核来完成初始化为0的操作。例如：函数外定义的数组，它会在程序执行之前被内核全部初始化为0。 栈区\n自动变量以及每次函数调用时需要保存的信息都被保存在这个区域。 堆区\n通常在堆区进行动态内存分配。 对于Intel x86处理器上的Linux操作系统而言，典型的存储空间布局如下：\n命令行参数和环境变量 命令行参数是指从命令行执行程序的时候，给程序的参数。C语言总是从main函数执行的，它的命令行参数被ISO C和POSIX规定为如下：\n1 int main(int argc,char *argv[]); main函数的第一个参数argc保存的是程序执行的时候，命令行输入的参数总个数。其中第0个参数就是被执行的程序名字。第二个参数argv是用来保存命令行参数的。ISO C和POSIX都要求argv[argc]是一个空指针。\n一个简单的实例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main(int argc,char *argv[]) { printf(\u0026#34;程序执行名：%s\\n\u0026#34;,argv[0]); printf(\u0026#34;参数列表：\\n\u0026#34;); for (int i = 1; i \u0026lt; argc; i++) { printf(\u0026#34;%s\\n\u0026#34;,argv[i]); } return 0; } 执行结果如下： 现在，POSIX规定了不使用第三个参数，通常使用getenv函数和putenv函数来访问环境变量。\n每次程序都有一张环境表，当我们需要查看整个环境的时候，可以使用全局变量environ。它包含了该指针数字的地址。\nextern char **environ;\n我们来写个程序打印一下全部的环境变量。\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;stdio.h\u0026gt; extern char **environ; int main(int argc,char *argv[]) { for (int i = 0; NULL != environ[i]; i++) { printf(\u0026#34;%s\\n\u0026#34;,environ[i]); } return 0; } 执行以后的结果如下： 依照惯例，环境变量应该是name=value这样的字符串构成。ISO C给我们提供了一些和环境变量有关的函数。可以通过以下方法查询：\n1 2 man getenv man setenv ","date":"2023-07-25T00:00:00Z","permalink":"https://wesleyel.github.io/p/linux-process-memory-layout/","title":"Linux Process 的内存布局"},{"content":"该片由山田洋次执导，倍赏千惠子、高仓健、吉冈秀隆等主演，于1980年3月15日出品。\n日本的北海道，差不多类似于国内的大西北。在电影拍摄的年代，这里仍然是一片苦寒之地。土地广袤，但产出贫乏，狂风骤雨的夏季，雪虐风饕的冬季，无不摧残着生活在这里的人们。\n女主人公风见民子既要独自支撑养牛场，还要抚养儿子武志。年轻时的她为了爱情，毅然断绝家里的联系，与一个即将去北海道开荒的人私奔。两人白手起家建立起这座农场，本来日子虽然苦，却还过得去。但几年前，丈夫撒手人寰，农场一下成了难以支撑的负担。她，勤劳、倔强、柔弱却坚强，默默承受所有的苦楚，却能用一颗善良的心教育孩子。\n表弟胜男带着新婚妻子佳代子来农场看望。饭桌上，民子开玩笑地说着表弟小时候的糗事，胜男说着表姐高中时多么年轻漂亮，气氛是轻松喜悦的。临别时，胜男笑着对表姐说：“祝你幸福”。但镜头随着汽车渐行渐远后，佳代子察觉到胜男异样的神情。眼泪湿润了胜男的脸庞，他感叹道：“表姐，过得真辛苦啊”。\n含蓄地表达，却刻画出了最动人的深情。内心深处最柔软的角落都被触动，在酸楚中一遍又一遍回味着最本初的真情。\n男主人公田岛耕作，结实肯干、沉默寡言。他用宽阔的肩膀为民子撑起了一片天，如同一只默默耕耘的黄牛一般，沉默，不求回报。他替民子照顾牲畜、教育武志要像男子汉一样勇敢。在武志心里，他慢慢地填补了父亲的缺失。潜移默化中，他的英武、潇洒使民子产生了一种暧昧的情愫。在他告知即将离开的那个夜晚，民子再也无法保持坚强。她卸下了自己勇敢无惧，将柔弱的一面暴露出来。是他给了民子久违的安全感，民子扑在他怀里，恳求不要离去。但他还是克制着自己的感情，还是沉默着，始终保持一段距离。\n之所以隐身于这个人烟稀少的小镇，勤勤恳恳的过着不求回报的生活，是因为一次冲动。彼时，他曾经的妻由于偿还不清贷款而自缢，在妻子的灵堂前他忍受不了债主对妻子的谩骂，冲动下铸成大错，自那以后就亡命天涯。但在这里，他重新找到了家人的感觉。但理性告诉他，他没有资格再享受这种快乐。\n“叔叔，你去哪儿啊？”武志追在警车后边跑边喊，他并不知道内情，只是牵挂这个像父亲一样的人。田岛挥了挥手，以歉意、困窘的眼神回应，然后进入了警车。\n镜头一转，又是一个冬天。风雪吹破农场窗户的塑料纸，农场的大门敞开着，一片破败萧条。\n火车上，两名警员押送着田岛前去服刑，此时正停在农场附近的火车站。出乎意料地，她找到了被判四年有期徒刑并正被押去服刑的他。两人似乎不知道要如何开口，虻田急中生智，以一种借喻的口吻和民子对话，完成了民子对田岛亲情和爱情的告白。\n虻田问道：太太，好久不见，听说您不养奶牛，到镇上去工作了。\n此时，民子望向耕作回答：对。\n虻田又问：听说您跟您儿子在等您丈夫回来，要等他好几年，这是真的吗？\n民子笃定温柔地点了点头，临座一直望着民子的耕作早已眼含泪光。\n虻田回复并又问：真了不起啊！生活上有没有困难呐？\n民子答：有虻田先生照顾。\n虻田：啊，那混蛋，是他呀，是他在照顾你们啦？\n民子又肯定地答到：是。\n虻田：那好啊，太好呐！\n说完，虻田掩面而泣。田岛已是泪如雨下，他接过民子的手绢擦干眼泪、对着民子郑重地点头，接受了民子的告白。火车继续急驰，窗外一片白茫茫的大地。\n如此含蓄、简单、又温情的告白来自导演山田洋次对电影情节匠心的把握。没有刻意催泪，他只是在情节的自然发展中，把东方人对爱情的表白，用最生活、最朴实的仪式感呈现出来，是东方式的；是非常契合整个影片北海道牧场天高云远的基调的；是符合民子、耕作这样在日常劳作中情愫渐生、但又羞于言语直接表达的人设的。朝夕相处的日常已让耕作成为了自己生活的一部分，再含蓄的民子，在面对即将得到却又马上要失去的爱情的时候，她也必须要做点什么以告慰自己内心的呼唤。哪怕这意味着等待，但有等待就有希望。于是，在虻田的帮助下，她告白了耕作，这样的告白是属于普通人也许一生一次的伟大之举。\n","date":"2022-09-09T00:00:00Z","permalink":"https://wesleyel.github.io/p/a-distant-cry-from-spring/","title":"《远山的呼唤》只是未到伤心处"},{"content":"+++\n译自： (Emacs) Keyboard Shortcuts for Editing Text Fields in OS X\nby JASON BLEVINS (JULY 17, 2015)\n众所周知，MacOS 有一组键盘快捷键，其中常用方向键控制Web 表单、输入框、纯文本文档等文本字段的编辑。举个例子， ⌘←将光标移动到当前行的开头。\n尽管它们在官方的文档中有提及(Mac 键盘快捷键)，但似乎不太为人所知的是， MacOS 还原生支持某些 Emacs 键盘快捷键。 例如，要移动到当前行的开头或结尾，可以按 ⌃A 或 ⌃E。 要删除光标后当前行上的所有内容，请使用 ⌃K。 要调换光标左右两侧的字符的位置，请按 ⌃T。 要在当前行上居中视口，请按 ⌃L。 像这样的快捷用法比使用方向键更快，后者需要将手指从键盘的主行移开。\n下表比较了 Emacs 按键绑定与 MacOS 按键绑定（类似 Emacs 的子集）。 对于 MacOS 快捷键，我们使用常用符号来表示 Command ⌘、Shift ⇧、Option ⌥、Control ⌃、Caps Lock ⇪、Delete ⌫ 和 Function Fn 键，并且将所有字母用大写表示。\nEmacs 按键绑定以 Control C、Meta (Alt) M、Shift S 前缀和 Delete DEL 键，并且将所有字母用小写表示。\nEmacs 和 MacOS 键盘快捷键对比 对象 方向 Emacs MacOS 光标移动: 移动光标 by character, word, line, etc. char left C-b ⌃B ← right C-f ⌃F → word left M-b ⌃⌥B ⌥← right M-f ⌃⌥F ⌥→ line begin C-a ⌃A ⌘← end C-e ⌃E ⌘→ up C-p ⌃P ↑ down C-n ⌃N ↓ doc begin M-\u0026lt; ⌘↑ end M-\u0026gt; ⌘↓ 文本选中: 扩展选中文本 by character, word, paragraph, and line char left C-b ⌃⇧B ⇧← right C-f ⌃⇧F ⇧→ word left M-b ⌃⌥⇧B ⌥⇧← right M-f ⌃⌥⇧F ⌥⇧→ line begin C-a ⌃⇧A ⇧⌘← end C-e ⌃⇧E ⇧⌘→ up C-p ⌃⇧P ⇧↑ down C-n ⌃⇧N ⇧↓ 文本删除: 移除 characters, words, and lines char left C-h, DEL ⌃H ⌫ right C-d ⌃D word left M-DEL ⌥⌫ right M-d Fn+⌥⌫ line backwards C–0 C-k ⌘⌫ forwards C-k ⌃K 搜索: 查找文本和在结果间移动 result first C-s ⌘F next C-s ⌘G previous C-r ⇧⌘G 滚动: 滚动编辑窗口 page up M-v Fn+↑ down C-v ⌃V Fn+↓ recenter C-l ⌃L 杂项: 其他的插入、编辑等操作 char transpose C-t ⌃T line insert C-o ⌃O kill C-w ⌃K yank C-y ⌃Y 参考：\nText System Defaults and Key Bindings from the Cocoa Event Handling Guide in the Mac Developer Library. Additional Emacs keyboard shortcuts via a DefaultKeyBinding.dict file on GitHub that can be placed in ~/Library/KeyBindings. ","date":"2022-05-07T00:00:00Z","permalink":"https://wesleyel.github.io/p/emacs-style-keyboard-shortcut-of-macos/","title":"MacOS 的 Emacs 风格键盘快捷键"},{"content":"Introduction 大学4年即将结束，回想这段时间。有时一个机缘巧合，我们就会被吸引并走进一个新的世界。PT就是我在大一期间认识到的，这种Freeeee的感觉太好了。后来组了自己的NAS，装入大容量硬盘，开启我的下载做种之路。\n有时会遇到种子掉线的问题，虽然出现的频率很低，但每次出现都让人困恼不已。具体情况是因为torrent下载工具和NAS不在同一个设备上，每当突然掉电后，恢复启动的torrent下载工具无法确定种子进度，于是种子进度干脆显示成0%。要想恢复做种进度，需要对所有种子重新进行散列检测。\n对于数以TB的文件，重新检测不仅需要大量的时间，而且会消耗大量的硬盘写入量，这对无论哪种硬盘都是一个灾难。\n之前开发过qBittorrent和uTorrent的备份工具，没有达到预期效果。\n今天看到了这篇文章，感觉很有参考意义。本文就是在此基础上做的一点修改。\nqbittorrent-api qbittorrent-api 是qBittorrent Web API的Python实现。RTD\n它支持qBittorrent v4.1.0+版本，基本实现了所有API。\n支持的版本：\n1 2 3 4 5 6 7 8 from qbittorrentapi import Version versions = Version.supported_app_versions() print(sorted(versions)) # [\u0026#39;v4.1.0\u0026#39;, \u0026#39;v4.1.1\u0026#39;, \u0026#39;v4.1.2\u0026#39;, \u0026#39;v4.1.3\u0026#39;, \u0026#39;v4.1.4\u0026#39;, \u0026#39;v4.1.5\u0026#39;, \u0026#39;v4.1.6\u0026#39;, \u0026#39;v4.1.7\u0026#39;, # \u0026#39;v4.1.8\u0026#39;, \u0026#39;v4.1.9\u0026#39;, \u0026#39;v4.1.9.1\u0026#39;, \u0026#39;v4.2.0\u0026#39;, \u0026#39;v4.2.1\u0026#39;, \u0026#39;v4.2.2\u0026#39;, \u0026#39;v4.2.3\u0026#39;, \u0026#39;v4.2.4\u0026#39;, # \u0026#39;v4.2.5\u0026#39;, \u0026#39;v4.3.0\u0026#39;, \u0026#39;v4.3.0.1\u0026#39;, \u0026#39;v4.3.1\u0026#39;, \u0026#39;v4.3.2\u0026#39;, \u0026#39;v4.3.3\u0026#39;, \u0026#39;v4.3.4.1\u0026#39;, \u0026#39;v4.3.5\u0026#39;, # \u0026#39;v4.3.6\u0026#39;, \u0026#39;v4.3.7\u0026#39;, \u0026#39;v4.3.8\u0026#39;, \u0026#39;v4.3.9\u0026#39;, \u0026#39;v4.4.0\u0026#39;, \u0026#39;v4.4.1\u0026#39;, \u0026#39;v4.4.2\u0026#39;] qBittorrent有许多版本，有些版本API变化很大。官方WIKI中将WebUI API划为三个版本。\nState Version Current qBittorrent v4.1+ Previous qBittorrent v3.2.0-v4.0.4 Obsolete qBittorrent v3.1.x 有一些PT站点限定使用v3.*.*版本，这样的话，就需要自己更新API了。\n例如\nv3.*.*的login接口为 http://localhost:8080/login v4.1.*的login接口为http://localhost:8080/api/v2/auth/login 要寻找合适的版本，参考PT站的常见问题和sourceforge.\nSkip hash detection Bug fix 根据torrent_parser issue#11,\ntorrent_parser.py#L46: from typing_extensions import OrderedDict\n这一行是误加入，运行前应该手动在源码中删除。\nBitTorrentfastresume文件的解析包bencode似乎不支持python3了，这里使用bencodepy作为替代。\nFull code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 from qbittorrentapi import Client, LoginFailed import torrent_parser as tp from yaml import load import os import hashlib import bencodepy try: from yaml import CLoader as Loader except ImportError: from yaml import Loader def get_qb(config): # 获取客户端实例 qb = Client(host=\u0026#39;%s:%s\u0026#39; % (config[\u0026#39;ip\u0026#39;], config[\u0026#39;port\u0026#39;]), username=config[\u0026#39;user\u0026#39;], password=config[\u0026#39;pwd\u0026#39;]) # 客户端进行登录 try: qb.auth_log_in() except LoginFailed as e: print(e) # 输出客户端信息 print(f\u0026#39;qBittorrent: {qb.app.version}\u0026#39;) print(f\u0026#39;qBittorrent Web API: {qb.app.web_api_version}\u0026#39;) print() return qb # 根据种子路径获取其hash值 def get_hash(filename): with open(filename, \u0026#39;rb\u0026#39;) as f: torrent_data = f.read() metainfo = bencodepy.decode(torrent_data) info = metainfo[b\u0026#39;info\u0026#39;] return hashlib.sha1(bencodepy.encode(info)).hexdigest() # 加载配置文件 def load_config(): data = load(open(\u0026#39;./config.yml\u0026#39;, \u0026#39;rb\u0026#39;), Loader=Loader) return data # 获取种子文件列表信息 def pars_torrent(path): file_paths = [] data = tp.parse_torrent_file(path) info = dict(data[\u0026#39;info\u0026#39;]) if \u0026#39;files\u0026#39; in info.keys(): for item in info[\u0026#39;files\u0026#39;]: file_paths.append(info[\u0026#39;name\u0026#39;] + \u0026#39;\\\\\u0026#39; + \u0026#39;\\\\\u0026#39;.join(item[\u0026#39;path\u0026#39;])) else: file_paths.append(info[\u0026#39;name\u0026#39;]) return file_paths # 主程序入口 if __name__ == \u0026#39;__main__\u0026#39;: user_info = load_config() qb = get_qb(user_info[\u0026#39;qb\u0026#39;]) save_paths = user_info[\u0026#39;save_path\u0026#39;] # 输入种子所在目录 torrents_path = input(\u0026#34;请输入种子保存路径\u0026gt;\u0026gt;\u0026#34;) files = os.listdir(torrents_path) # 循环处理种子信息 for file in files: if not file.endswith(\u0026#39;.torrent\u0026#39;): continue print(\u0026#34;*********************** 当前处理种子文件：%s ***********************\u0026#34; % file) torrent_path = os.path.join(torrents_path, file) # 种子已经存在于客户端，跳过 hash_value = get_hash(torrent_path) torrent = qb.torrents_info(torrent_hashes=hash_value) if len(torrent) == 1: print(\u0026#34;当前种子已经存在于客户端，跳出……\u0026#34;) continue # 判断种子文件是否存在于常用的保存路径 torrent_files = pars_torrent(torrent_path) print(\u0026#39;种子文件包含%d个文件\u0026#39;%len(torrent_files)) for save_path in save_paths: flag = True for torrent_file in torrent_files: if not os.path.isfile(os.path.join(save_path, torrent_file)): print(\u0026#39;%s 文件不存在，跳出……\u0026#39; % os.path.join(save_path, torrent_file)) flag = False break if flag == True: qb.torrents_add(torrent_files=torrent_path, save_path=save_path, is_skip_checking=True, is_paused=True) print(\u0026#39;种子检验完毕，保存路径为%s，已经添加！！\u0026#39; % save_path) 1 2 3 4 5 6 7 # result qBittorrent: v4.1.4 qBittorrent Web API: 2.1.1 *********************** 当前处理种子文件：Severance.S01.1080p.ATVP.WEB-DL.DDP5.1.Atmos.H.264-TEPES.torrent *********************** 种子文件包含9个文件 种子检验完毕，保存路径为Y:\\Transmission\\DOWNLOADS，已经添加！！ 1 2 3 4 5 6 7 qb: ip: \u0026#34;192.168.123.189\u0026#34; port: \u0026#34;12345\u0026#34; user: admin pwd: adminadmin save_path: - Y:\\Transmission\\DOWNLOADS ","date":"2022-04-22T00:00:00Z","permalink":"https://wesleyel.github.io/p/qbittorrent-api-usage/","title":"qbittorrent-api 的一些用法"},{"content":" 这是我的哲学课作业，老师给了95分，我也很满意。\n希腊古瓮颂\n〔英国〕济慈 （屠岸 译）\n你——“平静”的保持着童贞的新娘，\n“沉默”和漫长的“时间”领养的少女，\n山林的历史家，你如此美妙地叙讲\n如花的故事，胜过我们的诗句：\n绿叶镶边的传说在你的身上缠，\n讲的可是神，或人，或神人在一道，\n活跃在滕坡，或者阿卡狄谷地？\n什么人，什么神？什么样姑娘不情愿？\n怎样疯狂的追求？竭力的脱逃？\n什么笛，铃鼓？怎样忘情的狂喜？\n听见的乐曲是悦耳，听不见的旋律\n更甜美；风笛呵，你该继续吹奏；\n不是对耳朵，而是对心灵奏出\n无声的乐曲，送上更多的温柔：\n树下的美少年，你永远不停止歌唱，\n那些树木也永远不可能凋枯；\n大胆的情郎，你永远得不到一吻，\n虽然接近了目标——你可别悲伤，\n她永远不衰老，尽管你摘不到幸福，\n你永远在爱着，她永远美丽动人!\n啊，幸运的树枝!你永远不掉下\n你的绿叶，永不向春光告别；\n幸福的乐手，你永远不知道疲乏，\n永远奏出永远新鲜的音乐；\n幸福的爱情!更加幸福的爱情!\n永远热烈，永远等待着享受，\n永远喘息着，永远是青春年少，\n这一切情态，都这样超凡入圣，\n永远不会让心灵餍足，发愁，\n不会让额头发烧，舌蔽唇焦。\n这些前来祭祀的都是什么人？\n神秘的祭司，你的牛向上天哀唤，\n让花环挂满在她那光柔的腰身，\n你要牵她去哪一座青葱的祭坛？\n这是哪一座小城，河边的，海边的，\n还是靠山的，筑一座护卫的城砦——\n居尼们倾城而出，赶清早去敬神？\n小城呵，你的大街小巷将永远地\n寂静无声，没有一个灵魂会回来\n说明你何以从此变成了荒城。\n啊，雅典的形状!美的仪态!\n身上雕满大理石少女和男人，\n树林伸枝柯，脚下倒伏着草莱：\n你呵，缄口的形体!你冷嘲如“永恒”\n教我们超脱思虑。冷色的牧歌!\n等老年摧毁了我们这一代，那时，\n你将仍然是人类的朋友，\n并且会见到另一些哀愁，你会这样说：\n“美即是真，真即是美”——这就是\n我们在地上所知道、该知道的一切。\n英国浪漫主义诗人济慈于1819年5月写下这首富有创造力的《希腊古瓮颂》，由于十四行诗的形式和他想要的音调不符，于是他开始发展自己的颂歌类型，这首颂歌是最早使用这种新形式的作品之一，它由五节组成，每节十行。颂歌的形式使诗人能更多地描绘古瓮上场景，并为提出疑问和发出感叹留出空间。\n在每一节，济慈都描绘或谈论了古瓮上的画面，特别是两个着重描述的场景，一个是情人追求爱人，一个是村民与牧师聚集祭祀。这两个场景都隐含着死亡与永生这一对范畴。在颂歌的最后，济慈提出“‘美即是真，真即是美’——这就是我们在地上所知道、也该知道的一切。”，这句话后来引起了许多阐释者的讨论。总之，全诗的一条明线是生命短促，情感易变，唯有艺术长存。下面结合颂词大意谈谈所思所感。\n颂歌大意 这是一首复杂而又神秘的颂歌，它的赞颂对象是一只希腊古瓮。这只古瓮上绘制着引人神思的田园画卷。世上有许多赞颂乡村场景的诗歌，却没一首有古瓮上的画卷描述得好。这只经历漫长时间、一直保持缄默的古瓮，就像一个亭亭玉立着、静默着的少女。她不曾受到人世纷争的搅扰和岁月无情的摧残。即使穿越时空，形体依旧完美。\n诗人注视着古瓮，想知道少女讲述了一个怎样的故事。画中的场景是在希腊哪里？她所描绘的人物是人吗，还是神呢，还是人神一道？那个不情愿的女性是什么身份？场景中疯狂追求的人和竭力脱逃的人是否处于一场狂欢之中？笛声和铃鼓在演奏什么样的音乐？\n在这个精美的古瓮面前，诗人被迷住了，顷刻间便步入了由思维构筑的美的殿堂。那幅画卷开始变得栩栩如生，拿着风笛的人物似乎也将音乐送进了现实。诗人说能听见的乐曲是悦耳的，但听不见的旋律更好。画卷中的人啊，请你继续演奏风笛，即使耳朵无法听到，但无声的旋律能吹入心灵。\n吹笛人永远不会停止吹笛——因为古瓮上的场景永远停在了这一刻，树木也永远不会落下他们的叶子。情郎几乎要吻到那位姑娘，但他们的嘴唇却永远无法接触。对此，诗人俏皮地告诉情郎，你无须悲伤。虽然吻永远不会发生，但你们将永远热恋如初，而她将永远美丽。\n诗人感叹树枝是幸运的，因为叶子永远不会落下，而它也春光永驻。吹笛人也是幸福的，因为他的歌曲将永远清新悦耳，永远流传。最幸福的是恋人们的爱情，他们的心永远热烈地跳动，永远年轻；远远超越活人的情感，绝不会使心灵悲伤、厌倦，不会让头脑发烧、嘴唇焦渴，不会经历恋人的痛苦。\n古瓮上那队牵着牛前往祭坛的人，又是个怎么样的故事？诗人疑惑：神秘的祭司，你带领的这些人是谁？你要把这身披花环，朝天哞叫的小牛牵到哪个青葱的祭坛？这些人来自哪个小镇？傍河傍海抑或是有水塘的乡村？居民们在清晨前往敬神，那小镇的街道便永远清静，再也没有一个灵魂返回。\n凝视着古瓮上的这些形象，诗人发出感叹：哦，雅典的形象！美丽的姿态！这些男男女女，他们身边的林木和脚下的青草，这些静默的形象啊，你们就像永恒一样，使我们超越今天的思想：你雕刻出来的冰冷的牧歌，哪怕我们都在暮年中凋落，你仍将清新依旧！在另外一些人的忧伤中，你还会像朋友一样抚慰人们：“美即是真，真即是美，”这涵括你们所知道和所需要知道的一切。\n关于死亡 瓮（Urn）原本是盛放骨灰的容器，这首颂歌有着诗人对永恒和死亡的复杂沉思。柏拉图的二元世界理论认为，世界由理念和现象构成。理念世界一成不变，永恒存在。而现象世界则会随着时间而消逝。以柏拉图的观点来看，死亡不过是形式的终结，灵魂将会不朽。对于死亡，济慈似乎没有在颂歌提出中明确的观点，他谈及了与死亡密切相关的“空虚”，当逐渐冰冷的古瓮无法提供热情后，他最终承认了死亡的不可否认。\n在颂词的开始，诗人形容古瓮是“沉默的”和“经过漫长时间领养的少女”，一股令人不安的神秘感已经开始形成。第二、三节中，古瓮上的人物显得幸福而无忧无虑，演奏中的恋人、吹笛的音乐家和丰富的大自然都在营造“快乐、幸福”的感觉，诗人还称赞古瓮上的恋人“永远富有活力，永远年轻”。但此时，更深的危机感开始产生。到第四节后，颂词的主题便不再那么热情，而是转为疑虑。神秘的牧师将小牛牵向祭坛，居民们聚集在牧师身旁。从此寂静无人的街道和没有一个灵魂居住的“荒凉”的城市，无不令人感到惊异。最终，诗人将评论转向现实，认为他们这代人将被“老年”所“摧毁”（waste）。\n不论是古瓮的制作者，还是古瓮上所描述的那个时代都早已消逝，生命转瞬即逝，令人感到恐惧。但古瓮上的人物却如此鲜活，描绘的少女永远“不会褪色”，田园里的树木春光永驻，这样看又会产生一种不朽的感觉。\n但画中的人物本身并不具有真正的活力，时间的停止不仅仅停止了死亡，也停止了生命。死亡不仅仅是生命的结束，而且是生命的一个独特部分。诗人对古瓮的渲染越是出色，越是让读者意识到，死亡不可避免。\n艺术、美与真理 济慈在这首颂词中探讨了艺术、美和真理之间的密切关系。济慈认为：只有通过美，才能接近真理——通过艺术，人才能获得美。从颂诗中“诗人”的发展过程来说，他观察了古瓮这件精美的艺术品，陶醉在“美”的世界中，最后得出了“美即是真，真即是美”的真理。颂诗没有明确说明艺术、美与真理之间的关系，但暗含这三者之间相互依赖，彼此密不可分。\n这首颂歌著名的结尾——“美即是真，真即是美”，在后世引起了许多争论，但至少在本诗的语境下，“美”与“真”是能相互转换、近乎等同的。而艺术的作用是创造这种“真”与“美”。正如古瓮的制造者试图描绘这个世界的真实与美丽，这首颂词也试图将“真”与“美”带入它对古瓮的描述当中。\n柏拉图在《会饮篇》提出了“永恒的，无始无终，不生不灭”的理式美，一切美的事物都以它为源泉，有了它，那一切美的事物才成其为美。而事物美不过是它的幻象、影子。在这首颂诗中，古瓮中的场景永远定格，这意味着这幅图画不仅是田园生活，而是已经成为一种“纯粹”的美——不必实际存在，也不会最终死亡或受到污染。古瓮的美代表了美本身，而不是对美的摹仿。在诗的最后，济慈认为美是人必须追求的东西。\n解释柏拉图式的诗歌 在《理想国》第二卷中，柏拉图提出对价值观尚未定型的幼儿进行音乐教育。柏拉图希望艺术的存在服务于城邦利益，要求为艺术必须是真实的、敬神的、内容有益的。在第十卷中，柏拉图允许一些诗人留在“理想国”里，赞颂诸神和英雄人物。但诗歌作为一种“模仿性”的艺术，只能是一种适意的消遣，远离真理而不是接近真理。\n从多种方面分析，柏拉图轻贱艺术在理想国中的地位。他认为艺术无法对城邦提供益处，还会滋生欲望、放松人内心的理性节制。《希腊古瓮颂》全诗富有隐喻和神秘感，似乎并不符合柏拉图对诗歌的标准，难以说这是柏拉图式的诗歌。\n柏拉图在《理想国》中多次运用神话、象征和比喻的手法来说明他的思想，宽泛地说，这种隐喻的表现方式也是一种语言艺术。那么符合这种艺术风格，能否被称为柏拉图式的诗歌呢？新柏拉图主义往往强调神秘玄奥的元素，鼓励诗歌创作要暖昧晦涩，并有意使用神秘的、象征性的语言。\n如此的话，济慈的颂歌一定程度上符合新柏拉图主义流派的要求，因为其中使用到了隐喻的手法。\n","date":"2022-01-14T00:00:00Z","permalink":"https://wesleyel.github.io/p/%E5%B8%8C%E8%85%8A%E5%8F%A4%E7%93%AE%E9%A2%82%E6%B5%85%E6%9E%90/","title":"《希腊古瓮颂》浅析"},{"content":"最佳实践 经过一段时间的研究，又有了新的看法。\n准备以下两种工具：\nmitmproxy Android Emulator(MuMu, BlueStack \u0026hellip;) mitmproxy mitmproxy最好使用pipx安装。因为mitmproxy运行在独立的venv中，使用pipx方便为mitmproxy安装额外的 python 包。\n1 2 brew install pipx pipx install mitmproxy 最好按照提示说明，使用pipx ensurepath修改环境变量。\n这样我们就可以为mitmproxy安装额外的 python 包了。\n1 pipx inject mitmproxy pycryptodome # 安装 pycryptodome 包，用于AES解码 将浏览器代理设置到8080端口，打开(mitm.it)[mitm.it]下载对应平台的证书。\nAndroid Emulator 抓包之前有两个步骤：\n设置手动代理 安装并信任自签名 https 证书 设置 WiFi 代理为主机8080端口：\n以下是简化的脚本1，先看看adb devices信息，是否已经连接。如果没有成功连接需要adb kill-server，再重试几次。或者参照后文2。 直接运行以下脚本./push.sh YOUR_CRT.crt：\n1 2 3 4 5 6 7 8 9 10 11 12 13 PEM_FILE_NAME=$1 echo \u0026#34;$PEM_FILE_NAME\u0026#34; hash=$(openssl x509 -inform PEM -subject_hash_old -in $PEM_FILE_NAME | head -1) OUT_FILE_NAME=\u0026#34;$hash.0\u0026#34; cp $PEM_FILE_NAME $OUT_FILE_NAME openssl x509 -inform PEM -text -in $PEM_FILE_NAME -out /dev/null \u0026gt;\u0026gt; $OUT_FILE_NAME echo \u0026#34;Saved to $OUT_FILE_NAME\u0026#34; adb shell mount -o rw,remount,rw /system adb push $OUT_FILE_NAME /system/etc/security/cacerts/ adb shell mount -o ro,remount,ro /system adb reboot 如果模拟器正常重启的话应该就可以了。\n抓包 运行mitmweb，通过 web 界面观察包的发送和接收。\nmitmproxy 是一个非常强大的工具，其用法如恒河沙数，无不天花乱坠。官方文档提供的用例很值得仔细参阅，这里只介绍一个简单的例子。\nContentView是显示request或response负载的界面。有时需要查看的payload不是明文的json或plain text，默认情况下会以raw格式显示。\n这样会很麻烦。\n所以可以考虑通过插件增加一个ContentView的选项，让请求以我想要的方式显示。模仿addons-examples/#contentview，以挂载脚本的方式启动mitmweb -S decode.py：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from mitmproxy import contentviews, flow from mitmproxy import http from mitmproxy.contentviews.json import format_json from Crypto.Cipher import AES import base64 import hashlib import json import random class ViewAESDecode(contentviews.View): name = \u0026#34;AES decode\u0026#34; def __call__( self, data: bytes, *, content_type: Optional[str] = None, flow: Optional[flow.Flow] = None, http_message: Optional[http.Message] = None, **unknown_metadata, ): jsdata = decrypt(data) jsdata = json.loads(jsdata) return \u0026#34;AES decode\u0026#34;, format_json(jsdata) def render_priority( self, data: bytes, *, content_type: Optional[str] = None, flow: Optional[flow.Flow] = None, http_message: Optional[http.Message] = None, **unknown_metadata, ): if \u0026#39;what I want\u0026#39; in flow.request.host: return 10 # 出现的权重，为10的话会在最前面 else: return 0 def decrypt(data): key = \u0026#39;1234567890123456\u0026#39; iv = \u0026#39;1234567890123456\u0026#39; mode = AES.MODE_CBC cryptor = AES.new(key, mode, iv) data = base64.b64decode(data) decrypted = cryptor.decrypt(data) return decrypted.decode(\u0026#39;utf-8\u0026#39;) def load(l): contentviews.add(view) def done(): contentviews.remove(view) 结果如下： ADB 无法连接的问题 打开 USB 调试。夜神的 USB 调试并不通过默认的 5037 端口与 adb 客户端通信，可能是考虑多开也许超过 16 个客户端的官方限制。\n一般情况下，只需以下步骤就能连接 adb\n1 2 3 4 5 6 7 8 9 # WSL ubuntu 18.04 wesley@WIN10:/mnt/c/Users/Vita/Desktop$ adb devices List of devices attached wesley@WIN10:/mnt/c/Users/Vita/Desktop$ adb connect 127.0.0.1:62001 connected to 127.0.0.1:62001 wesley@WIN10:/mnt/c/Users/Vita/Desktop$ adb devices List of devices attached 127.0.0.1:62001 device 虚拟机比较多时就无效了，需要手动找到端口2。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Powershell PS C:\\Users\\Vita\u0026gt; Get-Process | where name -like \u0026#34;Nox*\u0026#34; Handles NPM(K) PM(K) WS(K) CPU(s) Id SI ProcessName ------- ------ ----- ----- ------ -- -- ----------- 1037 184 177620 49000 161.20 28604 1 Nox 2006 173 1046392 46020 251.53 4716 1 NoxVMHandle 3058 16 6268 19040 0.67 27528 1 NoxVMSVC PS C:\\Users\\Vita\u0026gt; Get-NetTcpConnection -OwningProcess 4716 -State Listen LocalAddress LocalPort RemoteAddress RemotePort State AppliedSetting ------------ --------- ------------- ---------- ----- -------------- 127.0.0.1 64001 0.0.0.0 0 Listen 127.0.0.1 63001 0.0.0.0 0 Listen 127.0.0.1 62001 0.0.0.0 0 Listen 127.0.0.1 61001 0.0.0.0 0 Listen 依次尝试连接这些LocalPort，验证adb devices是否正常。\npwlin, “Android : add cert to system store,” Gist, Mar. 07, 2016. https://gist.github.com/pwlin/8a0d01e6428b7a96e2eb (accessed Nov. 25, 2021).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMateusz, “ADB can’t connect to Nox,” Stack Overflow, Jul. 06, 2018. https://stackoverflow.com/questions/51214825/adb-cant-connect-to-nox (accessed Nov. 25, 2021).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2021-11-26T00:00:00Z","permalink":"https://wesleyel.github.io/p/android-emulator-packet-capture-and-everything/","title":"Android 抓包以及 mitmproxy"},{"content":" RStudio\nR语言的好处 在做Teamfight Tactics分析时，我先通过Riot\u0026rsquo;s API收集到了许多场次的对局数据。如何将这些复杂的数据转换成可以直接使用的数据，方便进行分析呢？\n之前一直用的是Python，思路是通过pymongo包连接MongoDB提取数据，再通过python内建函数进行转换和分析。这样需要不停使用Table[\u0026quot;sub\u0026quot;]['subsub']这样的格式取得内部结构。这部分内容没有代码提示，需要程序员自行记忆每个Key对应的结构，不仅麻烦，而且容易出错。可以预计分析数据的时候会用到大量循环，而python的效率让人缺乏信心。再加上后续还有画图步骤，而matplotlib是一个非常麻烦的东西，我有点害怕。\n也考虑过使用Matlab，它的好处是不少循环可以转为向量化运算，速度会快不少，而且画图容易。Matlab的附加功能里有一个Database Toolbox Interface for MongoDB。我甚至已经使用它进行了一段时间分析了，但后面发现默认生成的.mat格式转换为其他格式比较困难。而且运行速度也不是很理想，消耗资源很大，400MB的数据量在运算时常常卡死我的电脑。也可能是因为我不常使用它，所有代码本身编写的也不够好。\n最后终于接触到了R语言，这真是个好工具。配合RStudio，顺手又高效。它解决了上面的所有问题，而且内建和社区的函数和包为分析过程提供了很大帮助，为我节省了很多时间。它的一些用法和其他语言显得有些奇怪，理解和熟悉需要一些时间，但R语言的学习绝对物超所值。\n李东风老师的开源R语言教程很好，推荐一下：https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/index.html\nR语言的数据类型 向量 向量是将若干个基础类型相同的值存储在一起，各个元素可以按序号访问。需要注意的是，R语言各种类型的数据结构的下标都是从1开始的。例如\n1 2 3 4 5 6 7 # 数值型 marks \u0026lt;- c(10, 6, 4, 7, 8) x \u0026lt;- c(1:3, 10:13) # 逻辑型 c(1, 3, 5) \u0026gt; 2 # [1] FALSE TRUE TRUE # 字符型 s1 \u0026lt;- c(\u0026#39;abc\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;a cat\u0026#39;, NA, \u0026#39;李明\u0026#39;) 内建的大多数函数以向量为参数时，会对向量内的元素逐个运算，然后返回一个和原来一样长的向量。\n1 2 3 4 5 sqrt(c(1, 4, 6.25)) # [1] 1.0 2.0 2.5 x \u0026lt;- c(33, 55, 11) order(x) # [1] 3 1 2 x[order(x)] # [1] 11 33 55 列表 R中列表(list)类型来保存不同类型的数据。一个主要目的是提供R分析结果输出包装：输出一个变量，这个变量包括回归系数、预测值、残差、检验结果等等一系列不能放到规则形状数据结构中的内容。实际上，数据框也是列表的一种，但是数据框要求各列等长，而列表不要求。\n列表可以命名，命名后类似字典，可以通过名字访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 rec \u0026lt;- list(name=\u0026#34;李明\u0026#34;, age=30, scores=c(85, 76, 90)) rec ## $name ## [1] \u0026#34;李明\u0026#34; ## ## $age ## [1] 30 ## ## $scores ## [1] 85 76 90 rec$age # 或 rec[[\u0026#34;age\u0026#34;]] 也可以通过下标访问，但需要两重中括号。如果使用单重方括号对列表取子集，结果还是列表而不是列表元素。\n1 2 3 4 5 6 7 8 rec[[3]] ## [1] 85 76 90 rec[[3]][2] ## [1] 76 rec[3] ## $scores ## [1] 85 76 90 要删除某个元素，直接将该元素赋值为NULL；添加元素则是直接为该元素赋值。\n1 2 3 4 5 6 7 8 9 10 rec[[\u0026#34;age\u0026#34;]] \u0026lt;- NULL rec[[\u0026#34;身高\u0026#34;]] \u0026lt;- 178 ## $name ## [1] \u0026#34;李明\u0026#34; ## ## $三科分数 ## [1] 85 0 90 ## ## $身高 ## [1] 178 数据框 数据框类似于数据库表或Excel数据表的形式。这样形式的数据在R中叫做数据框(data.frame)。数据框类似于一个矩阵，有$n$个横行、$p$个纵列，但各列允许有不同类型：数值型向量、因子、字符型向量、日期时间向量。同一列的数据类型相同。数据框是一个特殊的列表，其每个列表元素都是一个长度相同的向量。\n数据框可以说是处理数据的最佳方式，利用它可以轻松按列或按行取值，并且可以直接用向量化的方式计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 d\u0026lt;-data.frame(TraitsComb=character(0),Top4=double(0),Winner=double(0),AvgPlacement=double(0),PickTimes=integer(0)) print(d) ## [1] TraitsComb Top4 Winner AvgPlacement PickTimes ## \u0026lt;0 行\u0026gt; (或0-长度的row.names) d[1,]\u0026lt;-list(\u0026#34;a\u0026#34;, 1.2, 2.3, 3.4, 5) print(d) ## TraitsComb Top4 Winner AvgPlacement PickTimes ## 1 a 1.2 2.3 3.4 5 colnames(d) ## [1] \u0026#34;TraitsComb\u0026#34; \u0026#34;Top4\u0026#34; \u0026#34;Winner\u0026#34; \u0026#34;AvgPlacement\u0026#34; \u0026#34;PickTimes\u0026#34; d$Winner ## [1] 2.3 d[3] ## Winner ## 1 2.3 d[3][1] ## Winner ## 1 2.3 R语言函数 字符串 观察下面的例子，只用了1行代码就实现了我想要的字符串拼接。\n1 2 3 4 5 6 7 8 9 tiers\u0026lt;-rev(c(\u0026#34;DIAMOND\u0026#34;,\u0026#34;PLATINUM\u0026#34;,\u0026#34;GOLD\u0026#34;,\u0026#34;SILVER\u0026#34;,\u0026#34;BRONZE\u0026#34;,\u0026#34;IRON\u0026#34;)) ranks\u0026lt;-rev(c(\u0026#34;I\u0026#34;,\u0026#34;II\u0026#34;,\u0026#34;III\u0026#34;,\u0026#34;IV\u0026#34;,\u0026#34;V\u0026#34;)) tire_order\u0026lt;-lapply(tiers,function(x) paste(x,ranks,sep=\u0026#34;-\u0026#34;)) %\u0026gt;% unlist ## [1] \u0026#34;IRON-V\u0026#34; \u0026#34;IRON-IV\u0026#34; \u0026#34;IRON-III\u0026#34; \u0026#34;IRON-II\u0026#34; \u0026#34;IRON-I\u0026#34; \u0026#34;BRONZE-V\u0026#34; ## [7] \u0026#34;BRONZE-IV\u0026#34; \u0026#34;BRONZE-III\u0026#34; \u0026#34;BRONZE-II\u0026#34; \u0026#34;BRONZE-I\u0026#34; \u0026#34;SILVER-V\u0026#34; \u0026#34;SILVER-IV\u0026#34; ## [13] \u0026#34;SILVER-III\u0026#34; \u0026#34;SILVER-II\u0026#34; \u0026#34;SILVER-I\u0026#34; \u0026#34;GOLD-V\u0026#34; \u0026#34;GOLD-IV\u0026#34; \u0026#34;GOLD-III\u0026#34; ## [19] \u0026#34;GOLD-II\u0026#34; \u0026#34;GOLD-I\u0026#34; \u0026#34;PLATINUM-V\u0026#34; \u0026#34;PLATINUM-IV\u0026#34; \u0026#34;PLATINUM-III\u0026#34; \u0026#34;PLATINUM-II\u0026#34; ## [25] \u0026#34;PLATINUM-I\u0026#34; \u0026#34;DIAMOND-V\u0026#34; \u0026#34;DIAMOND-IV\u0026#34; \u0026#34;DIAMOND-III\u0026#34; \u0026#34;DIAMOND-II\u0026#34; \u0026#34;DIAMOND-I\u0026#34; 这里lapply是对列表遍历，将每个元素先赋值为x，然后应用function(x)函数。paste函数是将两个参数连接起来，sep是连接符。\n%\u0026gt;%是一个pipe，它将结果传递给另一个函数作为第一个参数。unlist是将列表转换为向量。\n排序 对一张以下格式的数据框排序，可以使用order函数。倒序只需要在排序的列名前加-号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 head(traits_comp_discribe) ## TraitsComb Top4 Winner AvgPlacement PickTimes ## 1 Transformer 0.253 0.025 5.696 79 ## 2 Bruiser,Cuddly,Glutton,Sister,Transformer 0.922 0.314 2.373 51 ## 3 Arcanist,Cuddly 0.662 0.166 3.593 145 ## 4 Socialite 0.217 0.024 6.133 83 ## 5 Chemtech,Twinshot 0.462 0.154 4.231 13 ## 6 Clockwork,Cuddly,Transformer 0.750 0.250 3.875 8 head(traits_comp_discribe[order(-traits_comp_discribe$Top4),]) ## TraitsComb Top4 Winner AvgPlacement PickTimes ## 7 Academy,Cuddly,Imperial 1 0.500 3.000 4 ## 11 Bruiser,Sister,Socialite 1 0.400 6.400 5 ## 32 Cuddly,Glutton,Sister,Socialite 1 0.333 2.000 3 ## 34 Mercenary 1 0.071 7.286 14 ## 37 Bruiser,Sister,Transformer,Twinshot 1 0.333 3.000 3 ## 38 Bodyguard,Cuddly,Syndicate 1 0.250 3.500 4 MongoDB MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富却最像关系数据库的。它提供了一个非常简单的接口，可以让你在简单的程序中操作数据库。\n在R语言中，连接MongoDB可以使用mongolite库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 install.packages(\u0026#34;mongolite\u0026#34;) library(mongolite) url \u0026lt;- \u0026#34;mongodb://user:pass@site:port\u0026#34; db\u0026lt;- \u0026#34;tft\u0026#34; # 数据库名 # 连接数据库 s_con \u0026lt;- mongo(collection=\u0026#39;summoner\u0026#39;, db=db, url=url) # 查询数据 （查询等级低于100的召唤师） summoners \u0026lt;- s_con$find(\u0026#39;{\u0026#34;summonerlevel\u0026#34;: { \u0026#34;$lt\u0026#34;: 100 }}\u0026#39;) head(summoners) ## id puuid summonerlevel summonertire summonerrank ## 1 4 ******** 66 PLATINUM I ## 2 5 ******** 1 DIAMOND II ## 3 6 ******** 85 MASTER I ## 4 8 ******** 1 PLATINUM IV ## 5 9 ******** 20 PLATINUM II ## 6 12 ******** 19 PLATINUM II ","date":"2021-11-10T00:00:00Z","permalink":"https://wesleyel.github.io/p/r-lang-useful-tricks/","title":"R语言列表操作和连接MongoDB经验之谈"},{"content":"找到一本电子书 以《the-way-to-go_ZH_CN》为例，先clone下来。\n预处理 GitBook使用简单的目录结构，通过 SUMMARY.md 目录文件来确定哪些文件被转换。原书目录是TOC.md，因此将TOC.md改名为SUMMARY.md。\n原书的图片链接都带上了?raw=true参数，导致转换后的PDF文件里图片无法正确显示，需要全部删除\n1 grep -rl \u0026#34;?raw=true\u0026#34; ./ | xargs sed -i \u0026#34;\u0026#34; \u0026#39;s/?raw=true//g\u0026#39; 开始转换 安装calibre，主要是需要ebook-converter这个命令行工具\n创建一个符号连接 1 sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin /usr/local/bin可以是$PATH$中的任何文件夹\n安装gitbook-cli，这时会自动编译安装gitbook 1 npm install gitbook-cli -g 转换之 1 gitbook pdf ./ ./book.pdf ","date":"2021-11-10T00:00:00Z","permalink":"https://wesleyel.github.io/p/convert-gitbook-to-pdf/","title":"通过Gitbook将Markdown电子书转换为PDF格式"}]