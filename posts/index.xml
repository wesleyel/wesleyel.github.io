<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Magical trees, take me home.</title><link>/posts/</link><description>Recent content in Posts on Magical trees, take me home.</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 13 Nov 2024 07:33:46 +0000</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Buildroot Cheatsheet</title><link>/posts/buildroot-cheetsheet/</link><pubDate>Wed, 04 Sep 2024 00:00:00 +0800</pubDate><guid>/posts/buildroot-cheetsheet/</guid><description>完整文档可以在官方网站找到。
快速开始一个buildroot项目 buildroot_repo=https://github.com/buildroot/buildroot.git buildroot_version=2022.11 buildroot_src=buildroot-$buildroot_version buildroot_defcfg=raspberrypi4_defconfig git clone --branch $buildroot_version --depth 1 $buildroot_repo make -C $buildroot_src defconfig BR2_DEFCONFIG=$buildroot_defcfg make -C $buildroot_src linux-reconfigure all 基本命令 Make 提示
使用 make help 获取所有可用目标的列表。
命令 描述 make 构建 rootfs make xyz_defconfig 选择配置文件 make menuconfig 打开配置菜单 make savedefconfig 将当前配置保存到 defconfig 文件中 make source 下载包的源代码 make clean 清理所有构建产品（包括构建目录、主机、暂存和目标树、镜像和工具链） make distclean 清理所有内容，包括配置 包管理 特定包的 make 目标
命令 描述 make &amp;lt;pkg&amp;gt; 构建一个包 make &amp;lt;pkg&amp;gt;-reinstall 重新安装一个包 make &amp;lt;pkg&amp;gt;-rebuild 重新构建一个包（这意味着重新安装） make &amp;lt;pkg&amp;gt;-reconfigure 重新配置一个包（这意味着重新构建） make &amp;lt;pkg&amp;gt;-dirclean 清理包目录 调试 命令 描述 make graph-depends 生成依赖关系图 make &amp;lt;pkg&amp;gt;-graph-depends 生成包的依赖关系图 目录结构 目录 描述 configs 单板的配置和 defconfig 文件的位置 package 包定义的位置 dl 下载的源代码压缩包 output/build 所有组件构建的目录 output/images 构建的内核、引导加载程序和根文件系统镜像的位置 output/staging 交叉编译工具链和用户空间包的头文件和库的位置（这是 host//sysroot 的软链） output/host 包括交叉编译工具链在内的主机工具的位置 output/target 几乎是最终的目标根文件系统 .</description></item><item><title>Yocto &amp; Bitbake Cheatsheet</title><link>/posts/yocto-cheetsheet/</link><pubDate>Wed, 04 Sep 2024 00:00:00 +0800</pubDate><guid>/posts/yocto-cheetsheet/</guid><description>完整文档可以在Yocto 文档网站找到。 参考自yoctoproject-cheatsheet。
Cli 命令 需要先通过source setup-environment设置Bitbake环境
命令 描述 bitbake 编译指定的 image bitbake -c 执行指定的 task。 可选的 task 有: fetch, unpack, patch, configure, compile, install, package, clean, cleansstate, rebuild, reconfigure, reinstall等。 bitbake -c cleanall 清理指定的 recipe. 包括工作目录和 sstate cache bitbake -c devshell 进入指定 recipe 的 shell 环境 bitbake -c listtasks 列出指定 recipe 的所有 task bitbake -c showappends 显示指定 recipe 的所有 append 文件 bitbake -e 显示指定 recipe 的所有变量 bitbake -s 列出所有可用的 recipe bitbake -S 显示指定 recipe 的依赖关系 bitbake &amp;ndash;graphviz &amp;ndash;ui=depexp 生成的包依赖关系图 bitbake-layers show-layers 显示所有的 layer bitbake-layers show-appends 显示所有的 append 文件 bitbake-layers show-recipes 显示所有的 recipe bitbake-layers show-recipes &amp;ldquo;gdb*&amp;rdquo; 搜索 recipe bitbake-layers show-depends 显示所有的依赖关系 变量语法和操作 参考自Bitbake User Manual</description></item><item><title>Linux Process 的内存布局</title><link>/posts/linux-memory-layout-of-process/</link><pubDate>Tue, 25 Jul 2023 22:17:00 +0800</pubDate><guid>/posts/linux-memory-layout-of-process/</guid><description>内存布局 一般而言，C程序通常由一下几个部分组成。
正文段
正文段是用于存储代码的，也称之为代码段。如果函数是可重入的，那么代码段是可以共享的。正文段通常都是只读的，以防止被更改。 初始化数据段
初始化数据段包含了程序中需要明确初始化的变量。 未初始化数据段
未初始化数据段也被称为bss段。这里的存放的数据是交由内核来完成初始化为0的操作。例如：函数外定义的数组，它会在程序执行之前被内核全部初始化为0。 栈区
自动变量以及每次函数调用时需要保存的信息都被保存在这个区域。 堆区
通常在堆区进行动态内存分配。 对于Intel x86处理器上的Linux操作系统而言，典型的存储空间布局如下：
命令行参数和环境变量 命令行参数是指从命令行执行程序的时候，给程序的参数。C语言总是从main函数执行的，它的命令行参数被ISO C和POSIX规定为如下：
int main(int argc,char *argv[]); main函数的第一个参数argc保存的是程序执行的时候，命令行输入的参数总个数。其中第0个参数就是被执行的程序名字。第二个参数argv是用来保存命令行参数的。ISO C和POSIX都要求argv[argc]是一个空指针。
一个简单的实例如下：
#include&amp;lt;stdio.h&amp;gt; int main(int argc,char *argv[]) { printf(&amp;#34;程序执行名：%s\n&amp;#34;,argv[0]); printf(&amp;#34;参数列表：\n&amp;#34;); for (int i = 1; i &amp;lt; argc; i++) { printf(&amp;#34;%s\n&amp;#34;,argv[i]); } return 0; } 执行结果如下： 现在，POSIX规定了不使用第三个参数，通常使用getenv函数和putenv函数来访问环境变量。
每次程序都有一张环境表，当我们需要查看整个环境的时候，可以使用全局变量environ。它包含了该指针数字的地址。
extern char **environ;
我们来写个程序打印一下全部的环境变量。
#include&amp;lt;stdio.h&amp;gt; extern char **environ; int main(int argc,char *argv[]) { for (int i = 0; NULL != environ[i]; i++) { printf(&amp;#34;%s\n&amp;#34;,environ[i]); } return 0; } 执行以后的结果如下： 依照惯例，环境变量应该是name=value这样的字符串构成。ISO C给我们提供了一些和环境变量有关的函数。可以通过以下方法查询：</description></item><item><title>MacOS 的 Emacs 风格键盘快捷键</title><link>/posts/emacs-style-keyboard-shortcut-of-macos/</link><pubDate>Sat, 07 May 2022 00:00:00 +0800</pubDate><guid>/posts/emacs-style-keyboard-shortcut-of-macos/</guid><description>译自： (Emacs) Keyboard Shortcuts for Editing Text Fields in OS X
by JASON BLEVINS (JULY 17, 2015)
众所周知，MacOS 有一组键盘快捷键，其中常用方向键控制Web 表单、输入框、纯文本文档等文本字段的编辑。举个例子， ⌘←将光标移动到当前行的开头。
尽管它们在官方的文档中有提及(Mac 键盘快捷键)，但似乎不太为人所知的是， MacOS 还原生支持某些 Emacs 键盘快捷键。 例如，要移动到当前行的开头或结尾，可以按 ⌃A 或 ⌃E。 要删除光标后当前行上的所有内容，请使用 ⌃K。 要调换光标左右两侧的字符的位置，请按 ⌃T。 要在当前行上居中视口，请按 ⌃L。 像这样的快捷用法比使用方向键更快，后者需要将手指从键盘的主行移开。
下表比较了 Emacs 按键绑定与 MacOS 按键绑定（类似 Emacs 的子集）。 对于 MacOS 快捷键，我们使用常用符号来表示 Command ⌘、Shift ⇧、Option ⌥、Control ⌃、Caps Lock ⇪、Delete ⌫ 和 Function Fn 键，并且将所有字母用大写表示。
Emacs 按键绑定以 Control C、Meta (Alt) M、Shift S 前缀和 Delete DEL 键，并且将所有字母用小写表示。</description></item><item><title>qBittorrent 的一些事儿</title><link>/posts/usage-of-qbittorrent/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0800</pubDate><guid>/posts/usage-of-qbittorrent/</guid><description>Introduction 大学4年即将结束，回想这段时间。有时一个机缘巧合，我们就会被吸引并走进一个新的世界。PT就是我在大一期间认识到的，这种Freeeee的感觉太好了。后来组了自己的NAS，装入大容量硬盘，开启我的下载做种之路。
有时会遇到种子掉线的问题，虽然出现的频率很低，但每次出现都让人困恼不已。具体情况是因为torrent下载工具和NAS不在同一个设备上，每当突然掉电后，恢复启动的torrent下载工具无法确定种子进度，于是种子进度干脆显示成0%。要想恢复做种进度，需要对所有种子重新进行散列检测。
对于数以TB的文件，重新检测不仅需要大量的时间，而且会消耗大量的硬盘写入量，这对无论哪种硬盘都是一个灾难。
之前开发过qBittorrent和uTorrent的备份工具，没有达到预期效果。
今天看到了这篇文章，感觉很有参考意义。本文就是在此基础上做的一点修改。
qbittorrent-api qbittorrent-api 是qBittorrent Web API的Python实现。RTD
它支持qBittorrent v4.1.0+版本，基本实现了所有API。
支持的版本：
from qbittorrentapi import Version versions = Version.supported_app_versions() print(sorted(versions)) # [&amp;#39;v4.1.0&amp;#39;, &amp;#39;v4.1.1&amp;#39;, &amp;#39;v4.1.2&amp;#39;, &amp;#39;v4.1.3&amp;#39;, &amp;#39;v4.1.4&amp;#39;, &amp;#39;v4.1.5&amp;#39;, &amp;#39;v4.1.6&amp;#39;, &amp;#39;v4.1.7&amp;#39;, # &amp;#39;v4.1.8&amp;#39;, &amp;#39;v4.1.9&amp;#39;, &amp;#39;v4.1.9.1&amp;#39;, &amp;#39;v4.2.0&amp;#39;, &amp;#39;v4.2.1&amp;#39;, &amp;#39;v4.2.2&amp;#39;, &amp;#39;v4.2.3&amp;#39;, &amp;#39;v4.2.4&amp;#39;, # &amp;#39;v4.2.5&amp;#39;, &amp;#39;v4.3.0&amp;#39;, &amp;#39;v4.3.0.1&amp;#39;, &amp;#39;v4.3.1&amp;#39;, &amp;#39;v4.3.2&amp;#39;, &amp;#39;v4.3.3&amp;#39;, &amp;#39;v4.3.4.1&amp;#39;, &amp;#39;v4.3.5&amp;#39;, # &amp;#39;v4.3.6&amp;#39;, &amp;#39;v4.3.7&amp;#39;, &amp;#39;v4.3.8&amp;#39;, &amp;#39;v4.3.9&amp;#39;, &amp;#39;v4.4.0&amp;#39;, &amp;#39;v4.4.1&amp;#39;, &amp;#39;v4.4.2&amp;#39;] qBittorrent有许多版本，有些版本API变化很大。官方WIKI中将WebUI API划为三个版本。
State Version Current qBittorrent v4.1+ Previous qBittorrent v3.2.0-v4.0.4 Obsolete qBittorrent v3.1.x 有一些PT站点限定使用v3.</description></item><item><title>《远山的呼唤》只是未到伤心处</title><link>/posts/a-distant-cry-from-spring/</link><pubDate>Sat, 16 Apr 2022 00:00:00 +0800</pubDate><guid>/posts/a-distant-cry-from-spring/</guid><description>该片由山田洋次执导，倍赏千惠子、高仓健、吉冈秀隆等主演，于1980年3月15日出品。
日本的北海道，差不多类似于国内的大西北。在电影拍摄的年代，这里仍然是一片苦寒之地。土地广袤，但产出贫乏，狂风骤雨的夏季，雪虐风饕的冬季，无不摧残着生活在这里的人们。
女主人公风见民子既要独自支撑养牛场，还要抚养儿子武志。年轻时的她为了爱情，毅然断绝家里的联系，与一个即将去北海道开荒的人私奔。两人白手起家建立起这座农场，本来日子虽然苦，却还过得去。但几年前，丈夫撒手人寰，农场一下成了难以支撑的负担。她，勤劳、倔强、柔弱却坚强，默默承受所有的苦楚，却能用一颗善良的心教育孩子。
表弟胜男带着新婚妻子佳代子来农场看望。饭桌上，民子开玩笑地说着表弟小时候的糗事，胜男说着表姐高中时多么年轻漂亮，气氛是轻松喜悦的。临别时，胜男笑着对表姐说：“祝你幸福”。但镜头随着汽车渐行渐远后，佳代子察觉到胜男异样的神情。眼泪湿润了胜男的脸庞，他感叹道：“表姐，过得真辛苦啊”。
含蓄地表达，却刻画出了最动人的深情。内心深处最柔软的角落都被触动，在酸楚中一遍又一遍回味着最本初的真情。
男主人公田岛耕作，结实肯干、沉默寡言。他用宽阔的肩膀为民子撑起了一片天，如同一只默默耕耘的黄牛一般，沉默，不求回报。他替民子照顾牲畜、教育武志要像男子汉一样勇敢。在武志心里，他慢慢地填补了父亲的缺失。潜移默化中，他的英武、潇洒使民子产生了一种暧昧的情愫。在他告知即将离开的那个夜晚，民子再也无法保持坚强。她卸下了自己勇敢无惧，将柔弱的一面暴露出来。是他给了民子久违的安全感，民子扑在他怀里，恳求不要离去。但他还是克制着自己的感情，还是沉默着，始终保持一段距离。
之所以隐身于这个人烟稀少的小镇，勤勤恳恳的过着不求回报的生活，是因为一次冲动。彼时，他曾经的妻由于偿还不清贷款而自缢，在妻子的灵堂前他忍受不了债主对妻子的谩骂，冲动下铸成大错，自那以后就亡命天涯。但在这里，他重新找到了家人的感觉。但理性告诉他，他没有资格再享受这种快乐。
“叔叔，你去哪儿啊？”武志追在警车后边跑边喊，他并不知道内情，只是牵挂这个像父亲一样的人。田岛挥了挥手，以歉意、困窘的眼神回应，然后进入了警车。
镜头一转，又是一个冬天。风雪吹破农场窗户的塑料纸，农场的大门敞开着，一片破败萧条。
火车上，两名警员押送着田岛前去服刑，此时正停在农场附近的火车站。出乎意料地，她找到了被判四年有期徒刑并正被押去服刑的他。两人似乎不知道要如何开口，虻田急中生智，以一种借喻的口吻和民子对话，完成了民子对田岛亲情和爱情的告白。
虻田问道：太太，好久不见，听说您不养奶牛，到镇上去工作了。
此时，民子望向耕作回答：对。
虻田又问：听说您跟您儿子在等您丈夫回来，要等他好几年，这是真的吗？
民子笃定温柔地点了点头，临座一直望着民子的耕作早已眼含泪光。
虻田回复并又问：真了不起啊！生活上有没有困难呐？
民子答：有虻田先生照顾。
虻田：啊，那混蛋，是他呀，是他在照顾你们啦？
民子又肯定地答到：是。
虻田：那好啊，太好呐！
说完，虻田掩面而泣。田岛已是泪如雨下，他接过民子的手绢擦干眼泪、对着民子郑重地点头，接受了民子的告白。火车继续急驰，窗外一片白茫茫的大地。
如此含蓄、简单、又温情的告白来自导演山田洋次对电影情节匠心的把握。没有刻意催泪，他只是在情节的自然发展中，把东方人对爱情的表白，用最生活、最朴实的仪式感呈现出来，是东方式的；是非常契合整个影片北海道牧场天高云远的基调的；是符合民子、耕作这样在日常劳作中情愫渐生、但又羞于言语直接表达的人设的。朝夕相处的日常已让耕作成为了自己生活的一部分，再含蓄的民子，在面对即将得到却又马上要失去的爱情的时候，她也必须要做点什么以告慰自己内心的呼唤。哪怕这意味着等待，但有等待就有希望。于是，在虻田的帮助下，她告白了耕作，这样的告白是属于普通人也许一生一次的伟大之举。</description></item><item><title>《希腊古瓮颂》浅析</title><link>/posts/impression-of-ode-on-a-grecian-urn/</link><pubDate>Fri, 14 Jan 2022 00:00:00 +0800</pubDate><guid>/posts/impression-of-ode-on-a-grecian-urn/</guid><description>希腊古瓮颂
〔英国〕济慈 （屠岸 译）
你——“平静”的保持着童贞的新娘，
“沉默”和漫长的“时间”领养的少女，
山林的历史家，你如此美妙地叙讲
如花的故事，胜过我们的诗句：
绿叶镶边的传说在你的身上缠，
讲的可是神，或人，或神人在一道，
活跃在滕坡，或者阿卡狄谷地？
什么人，什么神？什么样姑娘不情愿？
怎样疯狂的追求？竭力的脱逃？
什么笛，铃鼓？怎样忘情的狂喜？
听见的乐曲是悦耳，听不见的旋律
更甜美；风笛呵，你该继续吹奏；
不是对耳朵，而是对心灵奏出
无声的乐曲，送上更多的温柔：
树下的美少年，你永远不停止歌唱，
那些树木也永远不可能凋枯；
大胆的情郎，你永远得不到一吻，
虽然接近了目标——你可别悲伤，
她永远不衰老，尽管你摘不到幸福，
你永远在爱着，她永远美丽动人!
啊，幸运的树枝!你永远不掉下
你的绿叶，永不向春光告别；
幸福的乐手，你永远不知道疲乏，
永远奏出永远新鲜的音乐；
幸福的爱情!更加幸福的爱情!
永远热烈，永远等待着享受，
永远喘息着，永远是青春年少，
这一切情态，都这样超凡入圣，
永远不会让心灵餍足，发愁，
不会让额头发烧，舌蔽唇焦。
这些前来祭祀的都是什么人？
神秘的祭司，你的牛向上天哀唤，
让花环挂满在她那光柔的腰身，
你要牵她去哪一座青葱的祭坛？
这是哪一座小城，河边的，海边的，
还是靠山的，筑一座护卫的城砦——
居尼们倾城而出，赶清早去敬神？
小城呵，你的大街小巷将永远地
寂静无声，没有一个灵魂会回来
说明你何以从此变成了荒城。
啊，雅典的形状!美的仪态!
身上雕满大理石少女和男人，
树林伸枝柯，脚下倒伏着草莱：
你呵，缄口的形体!你冷嘲如“永恒”
教我们超脱思虑。冷色的牧歌!
等老年摧毁了我们这一代，那时，
你将仍然是人类的朋友，
并且会见到另一些哀愁，你会这样说：
“美即是真，真即是美”——这就是
我们在地上所知道、该知道的一切。
英国浪漫主义诗人济慈于1819年5月写下这首富有创造力的《希腊古瓮颂》，由于十四行诗的形式和他想要的音调不符，于是他开始发展自己的颂歌类型，这首颂歌是最早使用这种新形式的作品之一，它由五节组成，每节十行。颂歌的形式使诗人能更多地描绘古瓮上场景，并为提出疑问和发出感叹留出空间。
在每一节，济慈都描绘或谈论了古瓮上的画面，特别是两个着重描述的场景，一个是情人追求爱人，一个是村民与牧师聚集祭祀。这两个场景都隐含着死亡与永生这一对范畴。在颂歌的最后，济慈提出“‘美即是真，真即是美’——这就是我们在地上所知道、也该知道的一切。”，这句话后来引起了许多阐释者的讨论。总之，全诗的一条明线是生命短促，情感易变，唯有艺术长存。下面结合颂词大意谈谈所思所感。
颂歌大意 这是一首复杂而又神秘的颂歌，它的赞颂对象是一只希腊古瓮。这只古瓮上绘制着引人神思的田园画卷。世上有许多赞颂乡村场景的诗歌，却没一首有古瓮上的画卷描述得好。这只经历漫长时间、一直保持缄默的古瓮，就像一个亭亭玉立着、静默着的少女。她不曾受到人世纷争的搅扰和岁月无情的摧残。即使穿越时空，形体依旧完美。
诗人注视着古瓮，想知道少女讲述了一个怎样的故事。画中的场景是在希腊哪里？她所描绘的人物是人吗，还是神呢，还是人神一道？那个不情愿的女性是什么身份？场景中疯狂追求的人和竭力脱逃的人是否处于一场狂欢之中？笛声和铃鼓在演奏什么样的音乐？
在这个精美的古瓮面前，诗人被迷住了，顷刻间便步入了由思维构筑的美的殿堂。那幅画卷开始变得栩栩如生，拿着风笛的人物似乎也将音乐送进了现实。诗人说能听见的乐曲是悦耳的，但听不见的旋律更好。画卷中的人啊，请你继续演奏风笛，即使耳朵无法听到，但无声的旋律能吹入心灵。
吹笛人永远不会停止吹笛——因为古瓮上的场景永远停在了这一刻，树木也永远不会落下他们的叶子。情郎几乎要吻到那位姑娘，但他们的嘴唇却永远无法接触。对此，诗人俏皮地告诉情郎，你无须悲伤。虽然吻永远不会发生，但你们将永远热恋如初，而她将永远美丽。
诗人感叹树枝是幸运的，因为叶子永远不会落下，而它也春光永驻。吹笛人也是幸福的，因为他的歌曲将永远清新悦耳，永远流传。最幸福的是恋人们的爱情，他们的心永远热烈地跳动，永远年轻；远远超越活人的情感，绝不会使心灵悲伤、厌倦，不会让头脑发烧、嘴唇焦渴，不会经历恋人的痛苦。
古瓮上那队牵着牛前往祭坛的人，又是个怎么样的故事？诗人疑惑：神秘的祭司，你带领的这些人是谁？你要把这身披花环，朝天哞叫的小牛牵到哪个青葱的祭坛？这些人来自哪个小镇？傍河傍海抑或是有水塘的乡村？居民们在清晨前往敬神，那小镇的街道便永远清静，再也没有一个灵魂返回。
凝视着古瓮上的这些形象，诗人发出感叹：哦，雅典的形象！美丽的姿态！这些男男女女，他们身边的林木和脚下的青草，这些静默的形象啊，你们就像永恒一样，使我们超越今天的思想：你雕刻出来的冰冷的牧歌，哪怕我们都在暮年中凋落，你仍将清新依旧！在另外一些人的忧伤中，你还会像朋友一样抚慰人们：“美即是真，真即是美，”这涵括你们所知道和所需要知道的一切。
关于死亡 瓮（Urn）原本是盛放骨灰的容器，这首颂歌有着诗人对永恒和死亡的复杂沉思。柏拉图的二元世界理论认为，世界由理念和现象构成。理念世界一成不变，永恒存在。而现象世界则会随着时间而消逝。以柏拉图的观点来看，死亡不过是形式的终结，灵魂将会不朽。对于死亡，济慈似乎没有在颂歌提出中明确的观点，他谈及了与死亡密切相关的“空虚”，当逐渐冰冷的古瓮无法提供热情后，他最终承认了死亡的不可否认。
在颂词的开始，诗人形容古瓮是“沉默的”和“经过漫长时间领养的少女”，一股令人不安的神秘感已经开始形成。第二、三节中，古瓮上的人物显得幸福而无忧无虑，演奏中的恋人、吹笛的音乐家和丰富的大自然都在营造“快乐、幸福”的感觉，诗人还称赞古瓮上的恋人“永远富有活力，永远年轻”。但此时，更深的危机感开始产生。到第四节后，颂词的主题便不再那么热情，而是转为疑虑。神秘的牧师将小牛牵向祭坛，居民们聚集在牧师身旁。从此寂静无人的街道和没有一个灵魂居住的“荒凉”的城市，无不令人感到惊异。最终，诗人将评论转向现实，认为他们这代人将被“老年”所“摧毁”（waste）。
不论是古瓮的制作者，还是古瓮上所描述的那个时代都早已消逝，生命转瞬即逝，令人感到恐惧。但古瓮上的人物却如此鲜活，描绘的少女永远“不会褪色”，田园里的树木春光永驻，这样看又会产生一种不朽的感觉。
但画中的人物本身并不具有真正的活力，时间的停止不仅仅停止了死亡，也停止了生命。死亡不仅仅是生命的结束，而且是生命的一个独特部分。诗人对古瓮的渲染越是出色，越是让读者意识到，死亡不可避免。</description></item><item><title>Android 抓包以及 mitmproxy</title><link>/posts/android-emulator-packet-capture-and-everything/</link><pubDate>Fri, 26 Nov 2021 02:37:41 +0800</pubDate><guid>/posts/android-emulator-packet-capture-and-everything/</guid><description>最佳实践 经过一段时间的研究，又有了新的看法。
准备以下两种工具：
mitmproxy Android Emulator(MuMu, BlueStack &amp;hellip;) mitmproxy mitmproxy最好使用pipx安装。因为mitmproxy运行在独立的venv中，使用pipx方便为mitmproxy安装额外的python包。
brew install pipx pipx install mitmproxy 最好按照提示说明，使用pipx ensurepath修改环境变量。
这样我们就可以为mitmproxy安装额外的python包了。
pipx inject mitmproxy pycryptodome # 安装 pycryptodome 包，用于AES解码 将浏览器代理设置到8080端口，打开(mitm.it)[mitm.it]下载对应平台的证书。
Android Emulator 抓包之前有两个步骤：
设置手动代理 安装并信任自签名https证书 设置WiFi代理为主机8080端口：
以下是简化的脚本1，先看看adb devices信息，是否已经连接。如果没有成功连接需要adb kill-server，再重试几次。或者参照后文2。 直接运行以下脚本./push.sh YOUR_CRT.crt：
PEM_FILE_NAME=$1 echo &amp;#34;$PEM_FILE_NAME&amp;#34; hash=$(openssl x509 -inform PEM -subject_hash_old -in $PEM_FILE_NAME | head -1) OUT_FILE_NAME=&amp;#34;$hash.0&amp;#34; cp $PEM_FILE_NAME $OUT_FILE_NAME openssl x509 -inform PEM -text -in $PEM_FILE_NAME -out /dev/null &amp;gt;&amp;gt; $OUT_FILE_NAME echo &amp;#34;Saved to $OUT_FILE_NAME&amp;#34; adb shell mount -o rw,remount,rw /system adb push $OUT_FILE_NAME /system/etc/security/cacerts/ adb shell mount -o ro,remount,ro /system adb reboot 如果模拟器正常重启的话应该就可以了。</description></item><item><title>R语言列表操作和连接MongoDB经验之谈</title><link>/posts/r-lang-useful-tricks/</link><pubDate>Wed, 10 Nov 2021 17:28:19 +0800</pubDate><guid>/posts/r-lang-useful-tricks/</guid><description>RStudio
R语言的好处 在做Teamfight Tactics分析时，我先通过Riot&amp;rsquo;s API收集到了许多场次的对局数据。如何将这些复杂的数据转换成可以直接使用的数据，方便进行分析呢？
之前一直用的是Python，思路是通过pymongo包连接MongoDB提取数据，再通过python内建函数进行转换和分析。这样需要不停使用Table[&amp;quot;sub&amp;quot;]['subsub']这样的格式取得内部结构。这部分内容没有代码提示，需要程序员自行记忆每个Key对应的结构，不仅麻烦，而且容易出错。可以预计分析数据的时候会用到大量循环，而python的效率让人缺乏信心。再加上后续还有画图步骤，而matplotlib是一个非常麻烦的东西，我有点害怕。
也考虑过使用Matlab，它的好处是不少循环可以转为向量化运算，速度会快不少，而且画图容易。Matlab的附加功能里有一个Database Toolbox Interface for MongoDB。我甚至已经使用它进行了一段时间分析了，但后面发现默认生成的.mat格式转换为其他格式比较困难。而且运行速度也不是很理想，消耗资源很大，400MB的数据量在运算时常常卡死我的电脑。也可能是因为我不常使用它，所有代码本身编写的也不够好。
最后终于接触到了R语言，这真是个好工具。配合RStudio，顺手又高效。它解决了上面的所有问题，而且内建和社区的函数和包为分析过程提供了很大帮助，为我节省了很多时间。它的一些用法和其他语言显得有些奇怪，理解和熟悉需要一些时间，但R语言的学习绝对物超所值。
李东风老师的开源R语言教程很好，推荐一下：https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/index.html
R语言的数据类型 向量 向量是将若干个基础类型相同的值存储在一起，各个元素可以按序号访问。需要注意的是，R语言各种类型的数据结构的下标都是从1开始的。例如
# 数值型 marks &amp;lt;- c(10, 6, 4, 7, 8) x &amp;lt;- c(1:3, 10:13) # 逻辑型 c(1, 3, 5) &amp;gt; 2 # [1] FALSE TRUE TRUE # 字符型 s1 &amp;lt;- c(&amp;#39;abc&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;a cat&amp;#39;, NA, &amp;#39;李明&amp;#39;) 内建的大多数函数以向量为参数时，会对向量内的元素逐个运算，然后返回一个和原来一样长的向量。
sqrt(c(1, 4, 6.25)) # [1] 1.0 2.0 2.5 x &amp;lt;- c(33, 55, 11) order(x) # [1] 3 1 2 x[order(x)] # [1] 11 33 55 列表 R中列表(list)类型来保存不同类型的数据。一个主要目的是提供R分析结果输出包装：输出一个变量，这个变量包括回归系数、预测值、残差、检验结果等等一系列不能放到规则形状数据结构中的内容。实际上，数据框也是列表的一种，但是数据框要求各列等长，而列表不要求。</description></item><item><title>通过Gitbook将Markdown电子书转换为PDF格式</title><link>/posts/convert-gitbook-to-pdf/</link><pubDate>Wed, 10 Nov 2021 17:18:22 +0800</pubDate><guid>/posts/convert-gitbook-to-pdf/</guid><description>找到一本电子书 以《the-way-to-go_ZH_CN》为例，先clone下来。
预处理 GitBook使用简单的目录结构，通过 SUMMARY.md 目录文件来确定哪些文件被转换。原书目录是TOC.md，因此将TOC.md改名为SUMMARY.md。
原书的图片链接都带上了?raw=true参数，导致转换后的PDF文件里图片无法正确显示，需要全部删除
grep -rl &amp;#34;?raw=true&amp;#34; ./ | xargs sed -i &amp;#34;&amp;#34; &amp;#39;s/?raw=true//g&amp;#39; 开始转换 安装calibre，主要是需要ebook-converter这个命令行工具
创建一个符号连接 sudo ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin /usr/local/bin可以是$PATH$中的任何文件夹
安装gitbook-cli，这时会自动编译安装gitbook npm install gitbook-cli -g 转换之 gitbook pdf ./ ./book.pdf</description></item><item><title>Hello World</title><link>/posts/hello/</link><pubDate>Tue, 09 Nov 2021 17:18:22 +0800</pubDate><guid>/posts/hello/</guid><description>辗转反复多次，最后终于意识到比写博客有意思的是折腾博客。
下次记得留下一些被打败的凹痕，以作纪念。 - 蕾欧娜
console.log(&amp;#34;Hello World&amp;#34;);</description></item></channel></rss>